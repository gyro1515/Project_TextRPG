# 🎮 Project_TextRPG

- 개발 인원: 1명
- 개발 기간: 250708 ~ 250711(4일)
- C# 콘솔 환경에서 제작된 텍스트 기반 RPG 게임입니다.  
아이템 장착, 전투, 저장 기능 등 다양한 시스템이 구현되어 있으며,  
간단한 키 입력만으로 진행되는 **클래식한 텍스트 RPG의 매력**을 담았습니다.

---

## ✅ 구현 기능

### 1. ⌨️ 키 입력 처리
- 키보드 입력을 통해 메뉴를 탐색하고 기능을 수행합니다.

---

### 2. 🏁 게임 시작 화면
- 게임 시작 시 간단한 소개 문구가 출력됩니다.
- 마을에서 수행할 수 있는 행동들을 안내합니다.

---

### 3. 📋 상태 보기
- 캐릭터의 6가지 속성 정보를 출력합니다:
- 초기값은 고정되어 있으며, Lv, 아이템 장착에 따라 능력치가 변화합니다.

---

### 4. 🎒 인벤토리
- 현재 보유 중인 아이템 전체를 출력합니다.
- 장착 중인 아이템 앞에는 `[E]` 표시가 붙습니다.

---

### 5. 🛡️ 장착 관리
- 인벤토리에서 원하는 아이템을 장착할 수 있습니다.
- **아이템 부위당 하나만 장착**할 수 있습니다.

---

### 6. 🛍️ 상점
- 보유 중인 Gold와 상점 아이템 목록을 표시합니다.
- 각 아이템 오른쪽에는 가격이 표시되며,  
구매 시 `구매완료`로 표기됩니다.
- 원하는 아이템을 선택하여 구매할 수 있습니다.

---

### 7. 💸 아이템 판매
- 상점에서 판매 메뉴 선택 시 보유 아이템 목록이 출력됩니다.
- 판매가는 **구매가의 85%**입니다.
- **장착 중인 아이템은 판매할 수 없습니다.**

---

### 8. 🏰 던전
- 던전은 3단계 난이도와 **자동 / 수동 모드**가 있습니다.

#### 🔁 자동 모드
- **방어력** 기준으로 성공 여부를 판단합니다.
- 권장 방어력 미만:
  - 40% 확률로 실패 → 보상 없음, 체력 절반 감소
- 권장 방어력 이상:
  - 성공 → 권장치 ±값에 따라 체력 소모량 결정
- **공격력**은 클리어 시 보상량에 영향을 줍니다.

#### 🐍 수동 모드 (스네이크 게임)
- 난이도에 따라 **맵 크기와 스네이크 속도**가 달라집니다.
- 클리어 / 실패에 따른 보상 구조는 자동 모드와 동일합니다.

---

### 9. 🐍 스네이크 미니 게임
- **입력 처리와 화면 출력**을 별도의 스레드로 구현하여  
스네이크의 움직임이 멈추지 않도록 구현하였습니다.

---

### 10. 📈 레벨 시스템
- 던전 클리어 시 경험치를 획득합니다.
- 경험치가 일정량 도달하면 자동으로 **레벨업**합니다.
- 다량의 경험치 획득 시 **한 번에 여러 레벨 상승**이 가능합니다.
- 레벨 1이 증가할 떄마다, 공격력과 방어력이 증가합니다.

---

### 11. 💤 휴식하기
- 마을에서 **500G를 지불하여 체력을 회복**할 수 있습니다.

---

### 12. 💾 게임 저장
- 시작 화면에서 **현재 플레이어의 모든 정보를 저장**할 수 있습니다.
- 게임 재실행 시 **자동으로 저장된 데이터를 불러옵니다.**

---

## 🛠️ 개발 환경

- **Language**: C#
- **Platform**: .NET Console App
- **IDE**: Visual Studio 2022

---

## ⚙️ Trouble Shooting

### 1. 아이템 참조 문제 (데이터 로드시 발생)

#### 1-1. 문제 발생 배경
- 프로젝트에서는 플레이어 데이터를 JSON 형식으로 저장하고, 게임 재시작 시 해당 데이터를 역직렬화하여 불러오는 구조를 사용했습니다.
- 이때, 플레이어의 능력치뿐만 아니라 인벤토리와 장비창에 포함된 아이템 정보도 함께 저장하고 불러옵니다.
- 초기 구현에서는 다음과 같은 방식으로 아이템을 처리했습니다:
  1) 상점에서 아이템을 구매하면 해당 객체를 얕은 복사 방식으로 인벤토리에 추가 
  2) 인벤토리의 아이템은 동일한 방식으로 장비창에도 전달
- 즉, 하나의 아이템 객체를 상점, 인벤토리, 장비창이 공유하는 구조였습니다. 
- 이 방식은 구현 당시 매우 효율적이었습니다. 예를 들어, 상점에서는 인벤토리를 별도로 확인하지 않아도 해당 아이템이 존재하는지 파악할 수 있었고, 장비창에서도 인벤토리 상태를 그대로 반영할 수 있었습니다.

#### 1-2. 문제 원인
- 저장된 데이터를 불러올 때, 역직렬화 과정에서 각 객체가 메모리에 새로 생성되기 때문에, 겉보기에는 동일한 아이템이라도 실제로는 서로 다른 인스턴스로 생성되었습니다.
- 예를 들어, 원래는 "상점 검 → 얕은 복사 → 인벤토리 검 → 얕은 복사 → 장비창 검"의 구조였다면, 로드 후에는 각각 완전히 다른 객체가 되어 있었습니다.
- 이로 인해 다음과 같은 문제가 발생했습니다:
  1) 장비창에서 인벤토리의 아이템을 장착하려 해도 같은 참조가 아니기 때문에 상태를 공유할 수 없었습니다.  
  2) 상점에서 판매 중인 아이템과 인벤토리의 아이템이 동일한 것으로 간주되지 않았습니다.

#### 1-3. 해결 방법
- 구조 자체를 변경하는 방식(예: 팩토리 패턴 적용, 객체 간 완전 분리 등)도 고려했으나, 장비창과 인벤토리가 동일한 씬에서 동시에 표시되어야 한다는 제약이 있었습니다.
- 따라서 기존 구조를 유지하되, 데이터 참조 방식만 조정하는 방향으로 결정했습니다.
- 해결 방식은 다음과 같습니다:
  - 데이터를 로드하는 시점에, 인벤토리의 아이템 객체를 기준으로 상점과 장비창이 동일한 인스턴스를 참조하도록 수동으로 매핑했습니다.
  - 즉, 기존처럼 얕은 복사를 유지하되, 역직렬화 이후 참조 관계를 수동으로 재정렬했습니다.
- 이를 통해 로드 이후에도 세 시스템(상점, 인벤토리, 장비창)이 동일한 아이템 인스턴스를 공유할 수 있게 되었으며, 기존 구조를 유지하면서도 데이터 불일치 문제를 해결할 수 있었습니다.

---

### 2. 키가 눌렸을 때만 입력 받기

#### 2-1. 문제 발생 배경
- 스네이크 게임은 멀티스레드를 활용하여 키 입력을 별도로 처리하는 구조로 구현되었습니다.
- 게임이 실행되는 동안에는 문제가 없었으나, 게임이 끝난 뒤 장면이 전환되었을 때 예상치 못한 입력 문제가 발생했습니다.

#### 2-2. 문제 원인
- 입력 처리는 `Console.ReadKey()`를 사용하여 키 입력을 즉시 대기하는 구조였습니다.
- 그러나 게임이 종료된 이후에도 입력 스레드가 한 번 더 `Console.ReadKey()`를 호출할 수 있었고, 이 대기가 다음 장면으로 전환된 이후의 `Console.ReadKey()`와 겹쳐, **두 번 입력해야만 다음으로 진행되는 문제**가 발생했습니다.

#### 2-3. 해결 방법
- 해결 방법은 간단했습니다.  
  `Console.KeyAvailable`을 사용하여 키 입력이 실제로 존재할 때만 `Console.ReadKey()`를 호출하도록 조건을 걸었습니다.
- 이를 통해 불필요한 입력 대기를 방지하고, 사용자가 키를 눌렀을 때만 정상적으로 입력이 처리되도록 구현할 수 있었습니다.

---

### 3. 선입력(입력 누적) 문제

#### 3-1. 문제 발생 배경
- 초기에는 키 입력을 한 번씩만 받는 방식으로 게임이 진행되었기 때문에 문제가 없었습니다.
- 그러나 테스트 과정에서 여러 키를 빠르게 입력할 경우, 입력이 버퍼에 누적되어 **씬 전환 이후에도 이전 입력이 자동으로 처리되는 현상**이 발생했습니다.

#### 3-2. 문제 원인
- `Console.ReadKey()`는 입력 버퍼에 남아 있는 키를 순차적으로 처리하는 구조이기 때문에, 전 씬에서 입력된 키 값들이 모두 저장된 상태로 남아 있었습니다.
- 이후 새로운 씬으로 넘어가더라도 해당 입력들이 자동으로 반영되었고, 이로 인해 다음과 같은 문제가 발생했습니다:
  - 사용자가 키를 누르지 않았는데도 캐릭터가 움직이거나 방향이 바뀌는 등 의도치 않은 동작 발생
  - 특히 스네이크 게임에서는 방향키를 연속 입력하면, 버퍼에 남아 있던 키 값들이 모두 소비되어 스네이크가 자동으로 방향을 바꾸는 문제가 발생

#### 3-3. 해결 방법
- 입력 버퍼를 비우는 기능을 추가하여 문제를 해결했습니다.
- Console.KeyAvailable을 통해 입력 버퍼에 키가 존재하는 동안 Console.ReadKey(true)를 반복 호출하여 모든 입력을 제거하도록 구성했습니다.
- 이 방식을 적용한 결과:
  - 씬 전환 이후에도 이전 입력이 영향을 주지 않게 되었으며,
  - 스네이크 게임에서는 방향키를 여러 번 눌러도 첫 번째 입력만 반영되고, 나머지는 무시되어 자동 방향 변경 문제가 말끔히 해결되었습니다.

## 💬 프로젝트 후기
- 스네이크 게임을 구현해보는 건 어떻겠냐는 제안을 받았고, 처음엔 단순히 구현으로만 끝날 줄 알았습니다.
- 그런데 개발을 진행하면서, 던전 클리어 방식을 ‘자동 / 수동 클리어’로 나눌 수 있겠다는 아이디어가 떠올랐고, 그 덕분에 스네이크 게임을 자연스럽게 던전 시스템과 연결시킬 수 있었습니다.
- 특히 기존에는 Console.ReadKey()를 이용해 입력이 들어올 때까지 화면이 멈추는 구조였는데, 스네이크에서는 캐릭터가 실시간으로 움직이고 동시에 화면 출력도 계속 이어져야 했기 때문에, 이 부분을 구현하며 많은 만족감을 느꼈습니다.
- 스네이크 게임을 처음 구상할 때 가장 고민이 많았던 부분은 바로 ‘실시간 입력 처리였습니다. 뱀이 멈추지 않고 계속 움직여야 하는 특성상, 일반적인 키 입력 대기 방식인, Console.ReadKey()로는 구현이 불가능했고, 결국 멀티스레드를 통해 입력을 따로 처리하는 방식을 택했습니다.
- 프로젝트 후반부에 키 입력 누적 문제를 해결하려다 Console.KeyAvailable을 알게 되면서 ‘굳이 멀티스레드가 아니어도 됐겠네?’라는 생각이 잠깐 스치긴 했지만, 지금 돌이켜보면 오히려 잘 된 일이라고 생각합니다. 이 기회를 통해 멀티스레드 입력 처리와 동기화에 대해 직접 고민하고, 실제로 적용해보는 소중한 경험을 할 수 있었다고 생각합니다.
